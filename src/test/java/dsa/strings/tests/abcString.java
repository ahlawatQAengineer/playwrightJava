package dsa.strings.tests;

public class abcString {




//    1. Longest Substring Without Repeating Characters
//    Problem:
//    Given a string, find the length of the longest substring that does not have any repeating characters.
//    Input:
//    String s = "abcabcbb";
//    Output:
//            3
//    Explanation:
//    The longest substring without repeating characters is "abc", and its length is 3.
//    Example Array Input:
//    String[] arr = {"abcabcbb", "bbbbb", "pwwkew"};
//    Expected Output:
//            [3, 1, 3]
//            2. Find the Longest Palindromic Substring
//
//
//
//
//
//
//    Problem:
//    Given a string, find the longest palindromic substring in the given string.
//            Input:
//    String s = "babad";
//    Output:
//            "bab" or "aba"
//    Explanation:
//    The longest palindromic substring is either "bab" or "aba", both of which have a length of 3.
//    Example Array Input:
//    String[] arr = {"babad", "cbbd", "a"};
//    Expected Output:
//            ["bab", "bb", "a"]
//            3. String Permutation
//
//
//
//
//
//
//    Problem:
//    Given two strings, check if one string is a permutation of the other.
//    Input:
//    String s1 = "abc";
//    String s2 = "cab";
//    Output:
//            true
//    Explanation:
//    The string "abc" is a permutation of "cab" because the characters in "abc" can be rearranged to form "cab".
//    Example Array Input:
//    String[] arr1 = {"abc", "abc", "abcd"};
//    String[] arr2 = {"cab", "abcd", "abc"};
//    Expected Output:
//            [true, false, true]
//            4. Substring with Concatenation of All Words
//
//
//
//
//
//    Problem:
//    Given a string s and a list of words words, find all the starting indices of s that are a concatenation of each word in words exactly once and without any intervening characters.
//    Input:
//    String s = "barfoothefoobarman";
//    String[] words = {"foo", "bar"};
//    Output:
//            [0, 9]
//    Explanation:
//    The substring "barfoo" starts at index 0, and "foobar" starts at index 9.
//    Example Array Input:
//    String[] arr = {"barfoothefoobarman", "wordgoodgoodword"};
//    String[] words1 = {"foo", "bar"};
//    String[] words2 = {"word", "good"};
//    Expected Output:
//            [[0, 9], [8]]
//            5. Implement Regular Expression Matching
//
//
//
//
//
//
//    Problem:
//    Implement regular expression matching with support for '.' and '*':
//            '.' matches any single character.
//            '*' matches zero or more of the preceding element.
//    Input:
//    String s = "aaab";
//    String p = "a*b";
//    Output:
//            true
//    Explanation:
//    The pattern "a*b" matches "aaab" because the '*' allows for zero or more as before the b.
//    Example Array Input:
//    String[] arr = {"aaab", "mississippi", "aab"};
//    String[] patterns = {"a*b", "mis*is*p*.", "c*a*b"};
//    Expected Output:
//            [true, false, true]




    // now i have three strings
    //these strings have name of states -   the first one in correct order
    //second one the string may have anagram of spme of the states present in first string
    //third string may have substrings from states of first string or second string
    //i need to find a list of states or substring of min length 3 which re presnt in all three strings


}
